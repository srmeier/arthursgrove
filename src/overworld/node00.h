//----------------------------------------------------------------------
#ifndef _NODE00_HEADER_
#define _NODE00_HEADER_

/* node00.h */
//----------------------------------------------------------------------
class Node00: public WorldNode {
protected:
	int numofbugs = 4;
	BugEntity* _bug[4];

public:
	Node00(void);
	~Node00(void);

	void update(void);
	void draw(void);
	SDL_bool canSpawn(int i, int j);
};

/* node00.cpp */
//----------------------------------------------------------------------
Node00::Node00(void) {
	int tiles[15][20] = {
		{0x08,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x0E,0x09},
		{0x0C,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x0D},
		{0x0A,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0B},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x30,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x30,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x30,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x30,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E,0x2E},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x31,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x32},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07},
		{0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07}
	};

	for(int j=0; j<15; j++) {
		for(int i=0; i<20; i++) {
			_tiles[j][i] = tiles[j][i];
		}
	}

	for(int i=0; i<numofbugs; i++) {
		SDL_bool bugSet = SDL_FALSE;

		while(!bugSet) {
			int ni = rand()%20;
			int nj = rand()%(15-4)+3;

			if(getTile(ni,nj)==GRASS_TILE_00) {
				bugSet = SDL_TRUE;
				_bug[i] = new BugEntity(16*ni, 16*nj);
			}
		}
	}
}

Node00::~Node00(void) {
	for(int i=0; i<numofbugs; i++) {
		delete _bug[i];
	}
}

void Node00::update(void) {
	int pi = _player->getI();
	int pj = _player->getJ();

	for(int i=0; i<numofbugs; i++) {
		int bi = _bug[i]->getI();
		int bj = _bug[i]->getJ();

		if(bi==pi&&bj==pj) {
			_bug[i]->hit(1);
		} else if(_player->weapon->active) {
			int si = _player->weapon->getI();
			int sj = _player->weapon->getJ();
			
			if(bi==si&&bj==sj) _bug[i]->hit(1);
		}

		_bug[i]->update();

		// /*
		if(!_bug[i]->active) {
			int ni = rand()%20;
			int nj = rand()%15;

			if(canSpawn(ni,nj))
				_bug[i]->setPos(16*ni, 16*nj);
		}
		// */
	}
}

void Node00::draw(void) {
	WorldNode::draw();

	for(int i=0; i<numofbugs; i++)
		if(_bug[i]->active) _bug[i]->draw();
}

SDL_bool Node00::canSpawn(int i, int j) {
	if(i<0||i>=20||j<0||j>=15) return SDL_FALSE;

	int pi = _player->getI();
	int pj = _player->getJ();

	return (SDL_bool) (
		(
		getTile(i,j)==GRASS_TILE_00
		)
		&&(i!=pi&&j!=pj)
	);
}

#endif
